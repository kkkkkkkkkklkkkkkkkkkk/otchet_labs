format PE CONSOLE
include 'C:\Users\Andre\Downloads\fasmw17330\INCLUDE\win32ax.inc'

entry start

;========= Сегмент данных ===========================================================================================================
section '.data?' data readable writeable
   x1 dd 6 dup(?)   ; Объявление массива с 6-ю элементами, которые могут содержать любое значение.
   size_x1 = $-x1   ; Вычисление размера массива, который вычисляется путем вычитания x1 из текущего адреса $.
   x2 dw 6 dup(?)   ; Объявление массива с 6-ю элементами, которые могут содержать любое значение.
   size_x2 = $-x2   ; Вычисление размера массива, который вычисляется путем вычитания x1 из текущего адреса $.
   A dw ?           ; Объявление неинициализированной переменной А, которая отвечает за размерность массива.


section '.data' data readable
   array1    dw 31,32,5,4,5,6          ; Объявление массива array1 со значениями 31,32,5,4,5,6
   size_a1 =  $ - array1               ; Вычисление размера массива, который вычисляется путем вычитания array1 из текущего адреса $.

   array2    db 1,2,3,4,5,6            ; Объявление массива array1 со значениями 1,2,3,4,5,6
   size_a2 =  $ - array2               ; Вычисление размера массива, который вычисляется путем вычитания array2 из текущего адреса $.

   array3 dw 7 dup(3)                  ; Объявление массива из 7 байтов, равных 3.
   size_a3 =  $ - array3               ; Вычисление размера массива, который вычисляется путем вычитания array3 из текущего адреса $.

   array4 dw 2 dup(71,10,11)           ; Объявление массива из 6 элементов типа dw, где каждый элемент занимает 2 байта.
   size_a4 =  $ - array4               ; Вычисление размера массива, который вычисляется путем вычитания array4 из текущего адреса $.

   size_of_dd = 4                      ; Объявляем переменную size_of_dd со значением 4.

section '.msg' data readable
   msg_d db ' %d ', 0Dh, 0Ah,0                     ; Строка форматирования для вывода целых чисел
   msg_s db 0Dh, 0Ah,' %s ',  0Dh, 0Ah,0           ; Строка форматирования для вывода строк

;========= Сегмент кода ===============================================================================================================
section '.code' code readable executable

macro print_array arr, arr_size, word_size         ; Макрос для вывода содержимого массива
{
     mov ebx,0                                     ; Счетчик массива
     @@:                                           ; Начало цикла
       cinvoke printf,  ' %d ', [arr+ebx],0        ; Вывод текущего элемента массива
       add ebx,word_size                           ; Увеличиваем счетчик массива на единицу
       cmp ebx , arr_size                          ; Если счетчик не достиг размера массива, то повторяем цикл.
       jne @b
}

start:
     cinvoke printf,  msg_s,'1 part',0             ; Выводим сообщение на экран с текстом '1 part'
     cinvoke printf,  msg_d,  size_a1              ; Выводим размер массива array1

     cinvoke printf,  msg_d, size_a2,0             ; Выводим размер массива array2
     cinvoke printf,  msg_d, size_x1,0             ; Выводим размер массива x1

     cinvoke printf,  msg_d, [array1+0],0          ; Выводим первый элемент массива array1
     cinvoke printf,  msg_d, [array1+2],0          ; Выводим третий элемент массива array1
     cinvoke printf,  msg_d, [array1+4],0          ; Выводим пятый элемент массива array1

     cinvoke printf,  msg_s,'2 part',0             ; Выводим сообщение на экран с текстом '2 part'
     xor ebx,ebx                                   ; Обнуляем регистр ebx
     @@:                                           ; Начало цикла
       cinvoke printf,  ' %d ',  [array3+ebx],0    ; Выводим текущий элемент массива array3
       add ebx,2                                   ; Увеличиваем счетчик ebx на 2
       cmp ebx , size_a3                           ; Сравниваем счетчик с размером массива array3
       jne @b                                      ; Если счетчик не достиг размера массива, то повторяем цикл

     print_array array4,size_a4,2                  ; Используем вывод массива array4 при помощи макроса

     cinvoke printf,  msg_s,'3 part',0             ; Выводим сообщение на экран с текстом '3 part'
     mov ax, [array1]                              ; Помещаем массив в регистр ax
     add ax, 2                                     ; Добавляем к ax значение 2
     mov [x2], ax                                  ; Перемещаем значение из ax в переменную x2
     print_array x2, size_x2, 2                    ; Используем вывод массива x2 при помощи макроса

     cinvoke printf,  msg_s,'4 part',0             ; Выводим сообщение на экран с текстом '4 part'
     print_array x1, size_x1, size_of_dd           ; Используем вывод на массива x1 при помощи макроса

     xor ebx,ebx                                   ; Обнуляем регистр ebx
     @@:                                           ; Начало цикла
       mov [x1+ebx],ebx                            ; Сохраняем значение переменной 'ebx' в текущий элемент массива x1
       add ebx,size_of_dd                          ; Увеличиваем значение переменной 'ebx' на размер элемента массива x1
       cmp ebx , size_x1                           ; Сравниваем 'ebx' с размером массива x1
       jne @b                                      ; Если ebx != размеру массива, то переходим на метку @@

     cinvoke printf,  msg_s,'',0                   ; Делаем вывод на экран
     print_array x1, size_x1, size_of_dd           ; Используем вывод массива x1 при помощи макроса

     cinvoke printf,  msg_s,'5 part',0             ; Выводим сообщение на экран с текстом '5 part'
     cinvoke printf,  msg_s,' Enter number',0      ; Выводим сообщение на экран с текстом 'Enter number: '
     cinvoke scanf,   ' %d', A                     ; Запрашиваем у пользователя число, которое будет помещенно в переменную А
     mov eax, dword [A]                            ; Помещаем значение переменной А размером 4 байта в 'eax'
     mov [x2+2], ax                                ; Сохраняем значение регистра в третий элемент массива x2
     print_array x2, size_x2, 2                    ; Используем вывод массива x2 при помощи макроса



     invoke  sleep, 5000                           ; Делаем задержку 5 секунд

     invoke  exit, 0                               ; Завершение программы
     ret                                           ; Выход из процедуры



;========= Таблица импорта =========================================================================================================
section '.idata' import data readable
 
 library msvcrt,'MSVCRT.DLL',\
    kernel32,'KERNEL32.DLL'
 
 import kernel32,\
    sleep,'Sleep'
 
 import msvcrt,\
    puts,'puts',\
    scanf,'scanf',\
    printf,'printf',\
    lstrlen,'lstrlenA',\
    exit,'exit'